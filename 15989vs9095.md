## BOJ 9095: 1, 2, 3의 순서쌍을 **고려하는** 경우

주어진 정수 $N$을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 문제입니다. 이때 순서가 다르면 다른 경우로 간주합니다 (예: 1+2와 2+1은 다릅니다).

### 점화식

$dp[N] = dp[N-1] + dp[N-2] + dp[N-3]$ (단, $N \\ge 4$)

  * $dp[N-1]$: 합의 마지막 숫자가 1인 경우
  * $dp[N-2]$: 합의 마지막 숫자가 2인 경우
  * $dp[N-3]$: 합의 마지막 숫자가 3인 경우

### 초기값

  * $dp[1] = 1$ (1)
  * $dp[2] = 2$ (1+1, 2)
  * $dp[3] = 4$ (1+1+1, 1+2, 2+1, 3)

-----

## BOJ 15989: 1, 2, 3의 순서쌍을 **고려하지 않는** 경우

주어진 정수 $N$을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 문제입니다. 이때 순서가 달라도 같은 경우로 간주합니다 (예: 1+2와 2+1은 같습니다). 즉, 오름차순으로 정렬된 합의 구성만 고려합니다.

### 점화식 (방법 1: 구성 요소를 나누어 계산)

$S[N] = A[N] + B[N] + C[N]$

  * $A[N]$: 1만으로 $N$을 구성하는 경우
      * $A[N] = 1$ (1+1+...+1)
  * $B[N]$: 1과 2를 이용하여 $N$을 구성하는 경우 (단, 2가 최소한 하나 포함되고 3은 포함되지 않음)
      * $B[N] = A[N-2] + B[N-2]$
  * $C[N]$: 1, 2, 3을 이용하여 $N$을 구성하는 경우 (단, 3이 최소한 하나 포함됨)
      * $C[N] = A[N-3] + B[N-3] + C[N-3]$

### 점화식 (방법 2: DP를 활용한 합산 방식)

$S[N]$을 $N$을 1, 2, 3의 합으로 나타내는 방법의 수라고 할 때, C++ 구현을 위한 점화식은 다음과 같습니다.

1.  모든 $S[i]$를 0으로 초기화하고, $S[0] = 1$로 설정합니다. ($N$이 0인 경우, 아무것도 더하지 않는 한 가지 방법으로 간주)
2.  **1을 사용하는 경우:** $S[i]$에 $S[i-1]$을 더합니다. 이는 $i-1$을 만들 수 있는 모든 방법에 1을 더하는 것을 의미합니다.
    ```cpp
    for (int i = 1; i <= N; i++) { S[i] += S[i-1]; }
    ```
3.  **2를 사용하는 경우:** $S[i]$에 $S[i-2]$를 더합니다. 이는 $i-2$를 만들 수 있는 모든 방법에 2를 더하는 것을 의미합니다.
    ```cpp
    for (int i = 2; i <= N; i++) { S[i] += S[i-2]; }
    ```
4.  **3을 사용하는 경우:** $S[i]$에 $S[i-3]$을 더합니다. 이는 $i-3$을 만들 수 있는 모든 방법에 3을 더하는 것을 의미합니다.
    ```cpp
    for (int i = 3; i <= N; i++) { S[i] += S[i-3]; }
    ```

P.S) 내가 정리하니까 md 양식이 깨져서 gemini한테 부탁해서 정리함
