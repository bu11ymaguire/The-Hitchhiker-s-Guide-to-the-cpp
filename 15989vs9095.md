# BOJ 9095: (1,2,3)의 순서쌍을 고려해서 
- dp[N] = dp[N-1] (끝이 1으로 끝나는 경우) + dp[N-2] (끝이 2으로 끝나는 경우) + dp[N-3] (끝이 3으로 끝나는 경우) # N>=4
( * dp[1]=1, dp[2]=2, dp[3]=3 )

# BOJ 15989: (1,2,3)의 순서쌍을 고려하지 않은 상태로
- S[N] = A[N] + B[N] + C[N]
A[N] = 1 (A: 1만을 이용해서 N을 구성)
B[N] = A[N-2] + B[N-2] (B: 1과 2를 이용해서 N을 구성)
C[N] = A[N-3] + B[N-3] + C[N-3] (C:1,2,3을 이용해서 N을 구성)

C++ 점화식95: (1,2,3)의 순서쌍을 고려해서 
- dp[N] = dp[N-1] (끝이 1으로 끝나는 경우) + dp[N-2] (끝이 2으로 끝나는 경우) + dp[N-3] (끝이 3으로 끝나는 경우) # N>=4
( * dp[1]=1, dp[2]=2, dp[3]=3 )

# BOJ 15989: (1,2,3)의 순서쌍을 고려하지 않은 상태로
- S[N] = A[N] + B[N] + C[N]
A[N] = 1 (A: 1만을 이용해서 N을 구성)
B[N] = A[N-2] + B[N-2] (B: 1과 2를 이용해서 N을 구성)
C[N] = A[N-3] + B[N-3] + C[N-3] (C:1,2,3을 이용해서 N을 구성)

C++ 점화식
S[0]= 1;
for(int i=1;i<=N;i++){ S[i] += S[i-1]; }
for(int i=2;i<=N;i++){ S[i] += S[i-2]; }
for(int i=3;i<=N;i++){ S[i] += S[i-3]; } 
