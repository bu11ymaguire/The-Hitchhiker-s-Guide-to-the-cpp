1106은 주어진 자원들로 가장 가성비있게 목표값에 도달하는 문제이다.
배열은 제한값보다 약간 널널하게 만들어준다. 왜냐하면 dp[limit] 보다 dp[limit+alpha]가 더 가격이 저렴할 수도 있기 때문이다.

vector<pair<int,int>> hello(N+1,{0,0});
for(int i = 1; i <= N; i++){
 int cost, visitor;
 cin >>cost >>visitor;
 hello[i] = {cost, visitor};
}

vector<int> value( limit+100 , INT_MAX );
for(int i=1; i <= N; i++)
{
 int current_cost = hello[i].first;
 int current_visitor = hello[i].second;
 for(int j = current_visitor ; j=value.size(); j++){
    value[j] = min ( value[j], value[j-current_visitor] + current_cost):
    }
}

for(int i=limit; i<dp.size();i++){
 minimum = min( minimum, dp[i] );
}

cout << minimum;

12865는 제한된 조건에서 가장 가치있는 조합을 찾는 문제이다.

vector<pair(int,int)> input(N+1, {0,0});

for(int i=1;i<=N;i++)
{
 int weight, value;
 cin >> weight >> value;
 input[i] = {weight, value};
}

vector<vector<int>> dp_1(N+1, vector<int>(limit+1,0));
vector<vector<int>> dp_2(N+1, 0);

for(int i =1; i<=N; i++){
 int current_weight = input[i].first;
 int current_value  = input[i].second;
 //SOL1 : 1차원 dp 배열
 for(int j = 1; j<=limit; j++){
 if(current_weight <=j)
 {
  dp_1[i][j] = max( dp[i-1][j], dp[i-1][j-1] + current_value);
 }
 else{
  dP_1[i][j] = dp[i-1][j];
 }
 //SOL2 : 2차원 dp 배열
 for(int j = limit; j>= current_weight; j++){
   dp_2[j] = max(dp_2[j], dp_2[j-curren_weight] + current_value);
 }   
