
-----

# DP 문제 풀이 요약: 1106 & 12865

## 📌 백준 1106: 호텔 (Unbounded Knapsack)

### 문제 정의

주어진 홍보 활동(비용, 고객 수)을 **여러 번** 사용하여, 최소 `C`명의 고객을 유치하는 **최소 비용**을 찾는 문제입니다.

### 핵심 전략

  - **DP 배열**: `dp[i]`는 '정확히 `i`명의 고객을 모으는 최소 비용'을 의미합니다.
  - **배열 크기**: 목표(`limit`)보다 넉넉하게 잡아야 합니다. 목표치보다 더 많은 고객을 유치하는 것이 오히려 저렴할 수 있기 때문입니다.
  - **루프 방향**: 하나의 활동을 여러 번 사용할 수 있으므로 **정방향(`j++`)** 루프를 사용합니다.

### C++ 코드

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int INF = 1e9; // 충분히 큰 값으로 초기화

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int limit, n;
    cin >> limit >> n;

    // dp[i] = i명의 고객을 모으는 최소 비용
    vector<int> dp(limit + 100, INF);
    dp[0] = 0; // 0명을 모으는 비용은 0원

    for (int i = 0; i < n; i++) {
        int cost, visitor;
        cin >> cost >> visitor;

        // 정방향(j++) 루프로 여러 번 사용하는 경우를 구현
        for (int j = visitor; j < dp.size(); j++) {
            dp[j] = min(dp[j], dp[j - visitor] + cost);
        }
    }

    // limit 이상을 확인하여 진짜 최솟값 찾기
    int result = INF;
    for (int i = limit; i < dp.size(); i++) {
        result = min(result, dp[i]);
    }

    cout << result;
    return 0;
}
```

-----

## 📌 백준 12865: 평범한 배낭 (0/1 Knapsack)

### 문제 정의

주어진 물건(무게, 가치)을 **한 번씩만** 사용하여, 제한된 무게 `K`를 넘지 않으면서 만들 수 있는 **최대 가치**를 찾는 문제입니다.

### 핵심 전략

  - **2D 풀이 (교과서)**: `dp[i][j]`는 '`i`번째 물건까지, `j` 무게 한도에서의 최대 가치'를 의미합니다.
  - **1D 풀이 (실전용)**: `dp[j]`는 '`j` 무게 한도에서의 최대 가치'를 의미하며, 메모리가 훨씬 효율적입니다.
  - **루프 방향**: 각 물건을 한 번만 사용해야 하므로, 1차원 풀이에서는 **역방향(`j--`)** 루프가 필수입니다.

### C++ 코드 (1차원 DP)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, limit;
    cin >> n >> limit;

    vector<int> dp(limit + 1, 0);
    vector<pair<int, int>> items(n + 1);

    for (int i = 1; i <= n; i++) {
        cin >> items[i].first >> items[i].second;
    }

    for (int i = 1; i <= n; i++) {
        int w = items[i].first;
        int v = items[i].second;
        
        // 역방향(j--) 루프로 각 아이템을 한 번만 사용하도록 구현
        for (int j = limit; j >= w; j--) {
            dp[j] = max(dp[j], dp[j - w] + v);
        }
    }

    cout << dp[limit];
    return 0;
}
```
